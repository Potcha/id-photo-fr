<!-- Version: V1.1 â€“ frontend wired to FastAPI (validate + mask/pipette) -->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="./assets/favicon.svg">
  <title>Photo d'identitÃ© & Passeport â€“ Normes FR (35Ã—45 mm) â€¢ V1.1</title>
  <style>
    :root{ --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --accent:#22c55e; --accent2:#38bdf8; --warn:#f59e0b; --danger:#ef4444 }
    *{box-sizing:border-box} html,body{height:100%}
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif;
      background:linear-gradient(180deg,#0b1224,#0f172a 22%,#0b1224); color:#e5e7eb; display:flex; flex-direction:column; gap:14px; align-items:center; padding:18px; }
    header{max-width:1100px; width:100%; display:flex; gap:14px; align-items:center; justify-content:space-between}
    h1{font-size:clamp(18px,4vw,24px); margin:0; font-weight:700; letter-spacing:0.3px}
    .subtitle{color:var(--muted); font-size:12.5px}
    .wrap{max-width:1100px; width:100%; display:grid; grid-template-columns:380px 1fr; gap:16px}
    .panel{background:rgba(17,24,39,.7); border:1px solid rgba(148,163,184,.15); border-radius:14px; padding:14px; box-shadow:0 12px 40px rgba(0,0,0,.35)}
    .controls{display:flex; flex-direction:column; gap:12px}
    .row{display:flex; gap:8px; flex-wrap:wrap}
    label.btn,input[type=file]::file-selector-button,button,.chip{appearance:none;border:none; border-radius:10px; padding:10px 12px; background:#0b1224; color:#e5e7eb; border:1px solid rgba(148,163,184,.2); cursor:pointer}
    input[type=file]{width:100%} label.btn{display:inline-flex; align-items:center; gap:8px}
    button.primary{background:linear-gradient(180deg,#10b981,#059669); border-color:transparent}
    button.ghost{background:transparent} button.warn{background:linear-gradient(180deg,#f59e0b,#d97706); border-color:transparent}
    button.danger{background:linear-gradient(180deg,#ef4444,#dc2626); border-color:transparent}
    button:disabled{opacity:.5; cursor:not-allowed}
    .hint{font-size:12px; color:var(--muted)} .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; background:#0b1224; padding:1px 6px; border-radius:6px; border:1px solid rgba(148,163,184,.25)}
    .canvasWrap{display:grid; grid-template-rows:auto 1fr; gap:8px}
    #preview{background:#e5e7eb; border-radius:14px; border:1px solid rgba(148,163,184,.2); box-shadow:inset 0 0 0 1px rgba(255,255,255,.02),0 40px 80px rgba(0,0,0,.35)}
    .legend{display:flex; align-items:center; justify-content:space-between; font-size:12px; color:var(--muted); gap:8px; flex-wrap:wrap}
    .badge{background:#0b1224; padding:6px 8px; border-radius:999px; border:1px solid rgba(148,163,184,.22)}
    details{border:1px solid rgba(148,163,184,.2); border-radius:12px; padding:8px 10px} details summary{cursor:pointer; font-weight:600}
    .grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px} input[type=range]{width:100%}
    @media (max-width:980px){ .wrap{grid-template-columns:1fr} }
    .chipRow{display:flex; gap:6px; flex-wrap:wrap} .chipBtn{padding:8px 10px; border-radius:999px; background:#0b1224; border:1px solid rgba(148,163,184,.2); cursor:pointer}
    .chipBtn.active{outline:2px solid var(--accent2)} .activeMode{outline:2px solid var(--accent2)} .segMeta{font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Photo d'identitÃ© & Passeport â€” <span style="color:var(--accent2)">Normes FR</span> (35Ã—45 mm)</h1>
      <div class="badge">Version <b>V1.1</b> â€” frontend â†” backend</div>
      <div class="subtitle">UI HTML/Canvas + FastAPI (masque & conformitÃ©). Export 300 DPI (413Ã—531 px).</div>
    </div>
    <div class="badge">Raccourcis : <span class="kbd">1</span> menton Â· <span class="kbd">2</span> sommet Â· <span class="kbd">3</span> Å“il G Â· <span class="kbd">4</span> Å“il D Â· <span class="kbd">Esc</span> sort Â· <span class="kbd">+</span>/<span class="kbd">âˆ’</span> zoom</div>
  </header>

  <div class="wrap">
    <section class="panel controls">
      <div>
        <label class="btn" for="file">ðŸ“· Importer une photo</label>
        <input id="file" type="file" accept="image/*" />
        <div class="hint">Face camÃ©ra, neutre, fond uni clair (gris/bleu), sans ombres.</div>
      </div>

      <div class="row">
        <button id="btnChin">Placer le <b>menton</b></button>
        <button id="btnCrown">Placer le <b>sommet</b></button>
        <button id="btnAuto" class="primary">Auto-ajuster 34 mm</button>
      </div>

      <div class="row">
        <button id="btnEyeL">Å’il gauche</button>
        <button id="btnEyeR">Å’il droit</button>
        <button id="btnAutoEyes" class="ghost">Aligner les yeux</button>
      </div>

      <div class="row">
        <button id="btnZoomIn">Zoom +</button>
        <button id="btnZoomOut">Zoom âˆ’</button>
        <button id="btnCenter" class="ghost">Centrer</button>
        <button id="btnRotateL" class="ghost">â†¶ 90Â°</button>
        <button id="btnRotateR" class="ghost">â†· 90Â°</button>
        <button id="btnReset" class="warn">RÃ©initialiser</button>
      </div>

      <details open>
        <summary>Rotation fine</summary>
        <div class="row" style="align-items:center; gap:8px">
          <button id="rotMinus">âˆ’1Â°</button>
          <input id="rotRange" type="range" min="-10" max="10" step="0.1" value="0" />
          <button id="rotPlus">+1Â°</button>
          <span class="hint" id="rotLabel">0.0Â°</span>
        </div>
      </details>

      <details>
        <summary>DÃ©tourage (via pipette Î”E â€“ backend)</summary>
        <div class="row">
          <button id="btnPickBg" class="ghost">ðŸŽ¯ Pipette fond +</button>
          <button id="btnResetSamples" class="ghost">RÃ©init. Ã©chantillons</button>
          <span class="segMeta">Ã‰chantillons : <b id="sampleCount">0</b></span>
          <button id="btnDetour" class="primary" disabled>Auto-dÃ©tourer</button>
          <button id="btnClearMask" class="danger" disabled>Effacer dÃ©tourage</button>
        </div>
        <div class="row">
          <label style="flex:1">
            <div class="hint">TolÃ©rance (Î”E LAB)</div>
            <input id="tolRange" type="range" min="6" max="60" step="1" value="18" />
          </label>
          <label style="flex:1">
            <div class="hint">Adouci (mm, bord)</div>
            <input id="softRange" type="range" min="0" max="12" step="1" value="4" />
          </label>
          <label class="chip" style="display:flex; align-items:center; gap:6px">
            <input id="showMask" type="checkbox" /> Afficher le masque
          </label>
        </div>
      </details>

      <details open>
        <summary>Fond (remplacement rapide)</summary>
        <div class="chipRow" id="bgChips">
          <button class="chipBtn" data-bg="#e5e7eb">Gris clair</button>
          <button class="chipBtn" data-bg="#dceeff">Bleu clair</button>
          <button class="chipBtn" data-bg="#e6f6e6">Vert clair</button>
          <button class="chipBtn" data-bg="#ffffff">Blanc</button>
        </div>
      </details>

      <details>
        <summary>Export</summary>
        <div class="grid" style="margin-top:8px">
          <button id="btnExportSingle" class="primary" disabled>Exporter 35Ã—45 mm (PNG 300 DPI)</button>
          <button id="btnExportA4" disabled>Planche A4 (300 DPI)</button>
          <button id="btnExport10x15" disabled>Planche 10Ã—15 cm / 4Ã—6â€³ (300 DPI)</button>
          <button id="btnExport4x6" disabled>Planche 4Ã—6 in (300 DPI)</button>
        </div>
      </details>
    </section>

    <section class="panel canvasWrap">
      <div class="legend">
        <div>Zone d'export : <b>35Ã—45 mm</b> â€” 300 DPI (<span id="pxInfo">413Ã—531</span> px)</div>
        <div>Hauteur visage : <span id="facePx" class="badge">â€“</span></div>
        <div>Yeux Î” : <span id="eyesBadge" class="badge">â€“</span></div>
        <div>ConformitÃ© : <span id="okBadge" class="badge">Non</span></div>
      </div>
      <canvas id="preview" width="413" height="531"></canvas>
      <div class="hint">Maintiens le clic sur l'image pour dÃ©placer les repÃ¨res. Molette : zoom. Glisser : pan. Ã‰chap pour sortir d'un mode.</div>
    </section>
  </div>

  <script>
  (function(){
    // === Backend ===
    const API_URL = window.API_URL || 'http://localhost:8000';
    let currentFile = null;   // pour /mask/pipette
    let bgSamplesXY = [];     // [{x,y}]

    // === FR specs ===
    const DPI = 300, PX_PER_MM = DPI/25.4;
    const OUT_W = Math.round(35*PX_PER_MM), OUT_H = Math.round(45*PX_PER_MM);
    const FACE_MIN = 32*PX_PER_MM, FACE_MAX = 36*PX_PER_MM, FACE_TARGET = 34*PX_PER_MM;
    const EYES_TOL_DEG = 2;

    // === DOM ===
    const file = document.getElementById('file');
    const can = document.getElementById('preview');
    const ctx = can.getContext('2d');
    const pxInfo = document.getElementById('pxInfo'); pxInfo.textContent = `${OUT_W}Ã—${OUT_H}`;
    const facePxEl = document.getElementById('facePx'), eyesBadge = document.getElementById('eyesBadge'), okBadge = document.getElementById('okBadge');
    const btnChin = document.getElementById('btnChin'), btnCrown = document.getElementById('btnCrown');
    const btnEyeL = document.getElementById('btnEyeL'), btnEyeR = document.getElementById('btnEyeR'), btnAutoEyes = document.getElementById('btnAutoEyes');
    const btnAuto = document.getElementById('btnAuto'), btnCenter=document.getElementById('btnCenter'), btnZoomIn=document.getElementById('btnZoomIn'), btnZoomOut=document.getElementById('btnZoomOut');
    const btnRotateL=document.getElementById('btnRotateL'), btnRotateR=document.getElementById('btnRotateR'), btnReset=document.getElementById('btnReset');
    const btnExportSingle=document.getElementById('btnExportSingle'), btnExportA4=document.getElementById('btnExportA4'), btnExport10x15=document.getElementById('btnExport10x15'), btnExport4x6=document.getElementById('btnExport4x6');
    const rotRange=document.getElementById('rotRange'), rotMinus=document.getElementById('rotMinus'), rotPlus=document.getElementById('rotPlus'), rotLabel=document.getElementById('rotLabel');
    const btnPickBg=document.getElementById('btnPickBg'), btnResetSamples=document.getElementById('btnResetSamples'), btnDetour=document.getElementById('btnDetour'), btnClearMask=document.getElementById('btnClearMask');
    const tolRange=document.getElementById('tolRange'), softRange=document.getElementById('softRange'), showMask=document.getElementById('showMask'), sampleCount=document.getElementById('sampleCount');
    const btnBrushAdd=document.getElementById('btnBrushAdd'), btnBrushSub=document.getElementById('btnBrushSub'), brushSize=document.getElementById('brushSize');
    const btnUndo=document.getElementById('btnUndo'), btnRedo=document.getElementById('btnRedo'), chkDecontam=document.getElementById('chkDecontam');
    const bgChips=document.getElementById('bgChips'); let bgColor='#e5e7eb';

    // === State ===
    let img = new Image(), imgLoaded=false, rotationDeg=0, scale=1, tx=OUT_W/2, ty=OUT_H/2;
    let imgCanvas=document.createElement('canvas'), imgCtx=imgCanvas.getContext('2d');
    let maskCanvas=null, maskCtx=null, subjectCanvas=null, subjectCtx=null, maskTintCanvas=null;
    let chin=null, crown=null, eyeL=null, eyeR=null;
    let mode=null, isPanning=false, panStart={x:0,y:0}, startTx=0, startTy=0, isDraggingLM=false, dragType=null, isPainting=false;
    let facePxCurrent=null, lastCompliance=false;
    const undoStack=[], redoStack=[], UNDO_LIMIT=10;

    // === Helpers ===
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    function rad(d){ return d*Math.PI/180; }
    function setExportsEnabled(ok){ [btnExportSingle,btnExportA4,btnExport10x15,btnExport4x6].forEach(b=>b.disabled=!ok); okBadge.textContent = ok ? 'Oui' : 'Non'; okBadge.style.background = ok ? '#0b1224' : 'linear-gradient(180deg,#ef4444,#dc2626)'; }
    function updateModeUI(){ [btnChin,btnCrown,btnEyeL,btnEyeR,btnBrushAdd,btnBrushSub,btnPickBg].forEach(b=>b.classList.remove('activeMode')); if(mode==='chin') btnChin.classList.add('activeMode'); else if(mode==='crown') btnCrown.classList.add('activeMode'); else if(mode==='eyeL') btnEyeL.classList.add('activeMode'); else if(mode==='eyeR') btnEyeR.classList.add('activeMode'); else if(mode==='pickBg') btnPickBg.classList.add('activeMode'); else if(mode==='brushAdd') btnBrushAdd.classList.add('activeMode'); else if(mode==='brushSub') btnBrushSub.classList.add('activeMode'); }
    function eyesAngleDeg(){ if(!eyeL||!eyeR) return null; const L=imageToCanvas(eyeL.x,eyeL.y), R=imageToCanvas(eyeR.x,eyeR.y); return Math.atan2(R.y-L.y, R.x-L.x) * 180/Math.PI; }
    function drawMarker(x,y,color){ ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    function canvasToImage(cx,cy){ const dx=cx-tx, dy=cy-ty; const s=1/scale; const a=rad(-rotationDeg); const rx=dx*Math.cos(a)-dy*Math.sin(a), ry=dx*Math.sin(a)+dy*Math.cos(a); return {x: rx*s + img.width/2, y: ry*s + img.height/2}; }
    function imageToCanvas(ix,iy){ const dx=ix-img.width/2, dy=iy-img.height/2; const a=rad(rotationDeg); const rx=dx*Math.cos(a)-dy*Math.sin(a), ry=dx*Math.sin(a)+dy*Math.cos(a); return {x: rx*scale+tx, y: ry*scale+ty}; }
    function hexToRgb(hex){ const s=hex.replace('#',''); const n=parseInt(s,16); if(s.length===6) return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; return {r:229,g:231,b:235}; }

    // === Draw ===
    function draw(){
      ctx.save(); ctx.fillStyle=bgColor||'#e5e7eb'; ctx.fillRect(0,0,can.width,can.height); ctx.restore();
      if(imgLoaded){ const src=subjectCanvas||img; ctx.save(); ctx.translate(tx,ty); ctx.rotate(rad(rotationDeg)); ctx.scale(scale,scale); if(src===img){ ctx.drawImage(img,-img.width/2,-img.height/2); } else { ctx.drawImage(subjectCanvas,-subjectCanvas.width/2,-subjectCanvas.height/2); } ctx.restore(); }
      // frame + gauges
      ctx.save(); ctx.strokeStyle='rgba(56,189,248,0.9)'; ctx.lineWidth=2; ctx.strokeRect(1,1,OUT_W-2,OUT_H-2);
      const midX=OUT_W-18; ctx.strokeStyle='rgba(148,163,184,0.7)'; ctx.beginPath(); ctx.moveTo(midX,8); ctx.lineTo(midX,OUT_H-8); ctx.stroke();
      ctx.fillStyle='rgba(34,197,94,0.25)'; const rangeTop=(OUT_H/2)-(36*PX_PER_MM/2); ctx.fillRect(midX-4, rangeTop, 8, 36*PX_PER_MM);
      ctx.fillStyle='rgba(56,189,248,0.35)'; const targetTop=(OUT_H/2)-(34*PX_PER_MM/2); ctx.fillRect(midX-6, targetTop, 12, 2); ctx.restore();
      const chinC = chin ? imageToCanvas(chin.x,chin.y) : null; const crownC = crown ? imageToCanvas(crown.x,crown.y) : null;
      facePxCurrent=null;
      if(chinC && crownC){ ctx.save(); ctx.strokeStyle='#22c55e'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(chinC.x,chinC.y); ctx.lineTo(crownC.x,crownC.y); ctx.stroke(); drawMarker(chinC.x,chinC.y,'#22c55e'); drawMarker(crownC.x,crownC.y,'#22c55e'); facePxCurrent=Math.hypot(crownC.x-chinC.x,crownC.y-chinC.y); ctx.restore(); }
      const ang = eyesAngleDeg();
      if(ang !== null){ const L=imageToCanvas(eyeL?.x||0,eyeL?.y||0), R=imageToCanvas(eyeR?.x||0,eyeR?.y||0); const midY=(L.y+R.y)/2; const ok=Math.abs(ang)<=EYES_TOL_DEG; eyesBadge.textContent=`${ang.toFixed(1)}Â° ${ok?'(OK)':'(âœ—)'}`; eyesBadge.style.background=ok?'#0b1224':'linear-gradient(180deg,#ef4444,#dc2626)'; ctx.save(); ctx.strokeStyle=ok?'#22c55e':'#ef4444'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.stroke(); drawMarker(L.x,L.y, ctx.strokeStyle); drawMarker(R.x,R.y, ctx.strokeStyle); ctx.setLineDash([6,4]); ctx.strokeStyle='rgba(148,163,184,0.75)'; ctx.beginPath(); ctx.moveTo(8,midY); ctx.lineTo(OUT_W-8,midY); ctx.stroke(); ctx.setLineDash([]); ctx.restore(); }
      setExportsEnabled(lastCompliance);
      if(showMask.checked && maskCanvas){ if(!maskTintCanvas){ maskTintCanvas=document.createElement('canvas'); maskTintCanvas.width=maskCanvas.width; maskTintCanvas.height=maskCanvas.height; const mctx=maskTintCanvas.getContext('2d'); mctx.drawImage(maskCanvas,0,0); mctx.globalCompositeOperation='source-in'; mctx.fillStyle='rgba(255,0,0,0.35)'; mctx.fillRect(0,0,maskTintCanvas.width,maskTintCanvas.height); mctx.globalCompositeOperation='source-over'; } ctx.save(); ctx.translate(tx,ty); ctx.rotate(rad(rotationDeg)); ctx.scale(scale,scale); ctx.drawImage(maskTintCanvas,-maskTintCanvas.width/2,-maskTintCanvas.height/2); ctx.restore(); }
    }

    // === Backend calls ===
    async function validateBackend(){
      try{
        const body = { chin, crown, eyeL, eyeR, rotation_deg: rotationDeg, scale: scale, dpi: 300 };
        const res = await fetch(`${API_URL}/validate`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        if(!res.ok) throw new Error('validate failed');
        const data = await res.json();
        if(data.face_mm!=null && data.face_px_canvas!=null){
          facePxEl.textContent = `${Math.round(data.face_px_canvas)} px (${data.face_mm.toFixed(1)} mm)`;
          facePxEl.style.background = data.face_ok ? '#0b1224' : 'linear-gradient(180deg,#ef4444,#dc2626)';
        } else { facePxEl.textContent='â€“'; facePxEl.style.background='#0b1224'; }
        if(data.eyes_angle_deg!=null){
          eyesBadge.textContent = `${data.eyes_angle_deg.toFixed(1)}Â° ${data.eyes_ok?'(OK)':'(âœ—)'}`;
          eyesBadge.style.background = data.eyes_ok ? '#0b1224' : 'linear-gradient(180deg,#ef4444,#dc2626)';
        }
        lastCompliance = !!data.compliant;
        setExportsEnabled(lastCompliance);
      }catch(err){ console.error('[validate]', err); }
    }
    let validateTimer=null; function scheduleValidate(){ if(validateTimer) clearTimeout(validateTimer); validateTimer=setTimeout(()=>validateBackend(), 150); }

    async function generateMaskBackend(){
      try{
        if(!currentFile){ alert("Importe d'abord une photo."); return; }
        if(bgSamplesXY.length===0){ alert('Ajoute au moins un Ã©chantillon de fond.'); return; }
        const fd = new FormData();
        fd.append('file', currentFile);
        fd.append('payload', JSON.stringify({ samples: bgSamplesXY, tolerance: parseFloat(tolRange.value), softness: parseFloat(softRange.value) }));
        const res = await fetch(`${API_URL}/mask/pipette`, { method:'POST', body: fd });
        if(!res.ok) throw new Error('mask/pipette failed');
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const im = new Image();
        im.onload = ()=>{
          maskCanvas = document.createElement('canvas');
          maskCanvas.width = imgCanvas.width; maskCanvas.height = imgCanvas.height;
          maskCtx = maskCanvas.getContext('2d');
          maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
          maskCtx.drawImage(im,0,0,maskCanvas.width,maskCanvas.height);
          rebuildSubject(); maskTintCanvas=null; btnClearMask.disabled=true?false:true; draw();
          URL.revokeObjectURL(url);
        };
        im.src = url;
      }catch(err){ console.error(err); alert('Ã‰chec du dÃ©tourage cÃ´tÃ© serveur.'); }
    }

    // === Local mask helpers (brush + rebuild) ===
    function clearMask(){ maskCanvas=null; maskCtx=null; subjectCanvas=null; subjectCtx=null; maskTintCanvas=null; btnClearMask.disabled=true; draw(); }
    function pushUndo(){ if(!maskCanvas) return; const imgD = maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height); undoStack.push(imgD); if(undoStack.length>UNDO_LIMIT) undoStack.shift(); btnUndo.disabled=false; redoStack.length=0; btnRedo.disabled=true; }
    function rebuildSubject(){ if(!maskCanvas){ subjectCanvas=null; subjectCtx=null; return; } const W=imgCanvas.width, H=imgCanvas.height; subjectCanvas=document.createElement('canvas'); subjectCanvas.width=W; subjectCanvas.height=H; subjectCtx=subjectCanvas.getContext('2d'); subjectCtx.clearRect(0,0,W,H); subjectCtx.drawImage(imgCanvas,0,0); subjectCtx.globalCompositeOperation='destination-in'; subjectCtx.drawImage(maskCanvas,0,0); subjectCtx.globalCompositeOperation='source-over'; maskTintCanvas=null; }
    function paintAt(ix,iy,add){ if(!imgLoaded) return; if(!maskCanvas){ maskCanvas=document.createElement('canvas'); maskCanvas.width=imgCanvas.width; maskCanvas.height=imgCanvas.height; maskCtx=maskCanvas.getContext('2d'); const id=maskCtx.createImageData(maskCanvas.width,maskCanvas.height); const fillA=add?0:255; for(let i=0;i<id.data.length;i+=4){ id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=fillA; } maskCtx.putImageData(id,0,0); } pushUndo(); const r=parseInt(brushSize.value,10); const g=maskCtx.createRadialGradient(ix,iy,0, ix,iy,r); if(add){ g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0.2)'); maskCtx.globalCompositeOperation='source-over'; } else { g.addColorStop(0,'rgba(0,0,0,1)'); g.addColorStop(1,'rgba(0,0,0,0.2)'); maskCtx.globalCompositeOperation='destination-out'; } maskCtx.fillStyle=g; maskCtx.beginPath(); maskCtx.arc(ix,iy,r,0,Math.PI*2); maskCtx.fill(); maskCtx.globalCompositeOperation='source-over'; rebuildSubject(); draw(); btnUndo.disabled=false; btnClearMask.disabled=false; }

    // === Export helpers ===
    function compositeSubject(octx){ const src=subjectCanvas||img; if(src===img){ octx.drawImage(img,-img.width/2,-img.height/2); return; } if(!chkDecontam.checked){ octx.drawImage(subjectCanvas,-subjectCanvas.width/2,-subjectCanvas.height/2); return; } const W=subjectCanvas.width, H=subjectCanvas.height; const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H; const tctx=tmp.getContext('2d'); tctx.drawImage(subjectCanvas,0,0); const imgD=tctx.getImageData(0,0,W,H); const data=imgD.data; const bg=hexToRgb(bgColor); for(let i=0;i<data.length;i+=4){ const a=data[i+3]/255; if(a>0&&a<1){ const k=Math.pow(1-a,0.7); data[i]=Math.round(data[i]*(1-k)+bg.r*k); data[i+1]=Math.round(data[i+1]*(1-k)+bg.g*k); data[i+2]=Math.round(data[i+2]*(1-k)+bg.b*k); } } tctx.putImageData(imgD,0,0); octx.drawImage(tmp,-W/2,-H/2); }
    function exportSingle(){ const out=document.createElement('canvas'); out.width=OUT_W; out.height=OUT_H; const octx=out.getContext('2d'); octx.fillStyle=bgColor||'#e5e7eb'; octx.fillRect(0,0,OUT_W,OUT_H); octx.save(); octx.translate(tx,ty); octx.rotate(rad(rotationDeg)); octx.scale(scale,scale); compositeSubject(octx); octx.restore(); out.toBlob((blob)=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='photo_identite_FR_35x45mm_300dpi.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }, 'image/png'); }
    function gridFor(w,h){ const MARG=Math.round(4*PX_PER_MM); const pad=Math.round(2*PX_PER_MM); const cellW=OUT_W+pad; const cellH=OUT_H+pad; const cols=Math.max(1,Math.floor((w-2*MARG+pad)/cellW)); const rows=Math.max(1,Math.floor((h-2*MARG+pad)/cellH)); const usedW=cols*cellW-pad; const usedH=rows*cellH-pad; const startX=Math.floor((w-usedW)/2); const startY=Math.floor((h-usedH)/2); return {MARG,pad,cellW,cellH,cols,rows,startX,startY}; }
    function makeSheet(w,h,filename){ const sheet=document.createElement('canvas'); sheet.width=w; sheet.height=h; const sctx=sheet.getContext('2d'); sctx.fillStyle='#ffffff'; sctx.fillRect(0,0,w,h); const tile=document.createElement('canvas'); tile.width=OUT_W; tile.height=OUT_H; const tctx=tile.getContext('2d'); tctx.fillStyle=bgColor||'#e5e7eb'; tctx.fillRect(0,0,OUT_W,OUT_H); tctx.save(); tctx.translate(tx,ty); tctx.rotate(rad(rotationDeg)); tctx.scale(scale,scale); compositeSubject(tctx); tctx.restore(); const g=gridFor(w,h); for(let r=0;r<g.rows;r++) for(let c=0;c<g.cols;c++){ const x=g.startX + c*g.cellW; const y=g.startY + r*g.cellH; sctx.drawImage(tile,x,y); } sheet.toBlob((blob)=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }, 'image/png'); }
    function export10x15(){ const W=1200,H=1800; const g1=gridFor(W,H), g2=gridFor(H,W); if(g2.cols*g2.rows>g1.cols*g1.rows) makeSheet(H,W,'planche_10x15cm_300dpi.png'); else makeSheet(W,H,'planche_10x15cm_300dpi.png'); }
    function export4x6(){ makeSheet(1200,1800,'planche_4x6in_300dpi.png'); }

    // === Events ===
    ['change','input'].forEach(evt=>{ file.addEventListener(evt,(e)=>{ const f=(e.target.files && e.target.files[0])||null; if(f){ currentFile=f; loadImage(f); } }); });
    function loadImage(fileObj){ try{ const url=URL.createObjectURL(fileObj); img=new Image(); img.onload=()=>{ imgLoaded=true; imgCanvas.width=img.width; imgCanvas.height=img.height; imgCtx.drawImage(img,0,0); reset(true); scheduleValidate(); URL.revokeObjectURL(url); }; img.onerror=()=>{ alert('Impossible de lire ce fichier image.'); URL.revokeObjectURL(url); }; img.src=url; }catch(e){ console.error(e); alert('Erreur lors du chargement de l\'image.'); } }
    const setLM=(name)=>{ mode=name; updateModeUI(); draw(); };
    document.getElementById('btnChin').addEventListener('click', ()=>setLM('chin'));
    document.getElementById('btnCrown').addEventListener('click', ()=>setLM('crown'));
    document.getElementById('btnEyeL').addEventListener('click', ()=>setLM('eyeL'));
    document.getElementById('btnEyeR').addEventListener('click', ()=>setLM('eyeR'));
    btnAutoEyes.addEventListener('click', ()=>{ autoEyes(); scheduleValidate(); });
    rotRange.addEventListener('input', ()=>{ rotationDeg=parseFloat(rotRange.value); rotLabel.textContent=`${rotationDeg.toFixed(1)}Â°`; draw(); scheduleValidate(); });
    rotMinus.addEventListener('click', ()=>{ rotRange.value=(parseFloat(rotRange.value)-1).toString(); rotationDeg=parseFloat(rotRange.value); rotLabel.textContent=`${rotationDeg.toFixed(1)}Â°`; draw(); scheduleValidate(); });
    rotPlus.addEventListener('click', ()=>{ rotRange.value=(parseFloat(rotRange.value)+1).toString(); rotationDeg=parseFloat(rotRange.value); rotLabel.textContent=`${rotationDeg.toFixed(1)}Â°`; draw(); scheduleValidate(); });
    btnAuto.addEventListener('click', ()=>{ autoAdjust(); scheduleValidate(); });
    btnCenter.addEventListener('click', ()=>{ tx=OUT_W/2; ty=OUT_H/2; draw(); });
    btnZoomIn.addEventListener('click', ()=>{ scale*=1.05; draw(); scheduleValidate(); });
    btnZoomOut.addEventListener('click', ()=>{ scale/=1.05; draw(); scheduleValidate(); });
    btnRotateL.addEventListener('click', ()=>{ rotationDeg=(rotationDeg-90)%360; rotRange.value=rotationDeg; rotLabel.textContent=`${Number(rotRange.value).toFixed(1)}Â°`; draw(); scheduleValidate(); });
    btnRotateR.addEventListener('click', ()=>{ rotationDeg=(rotationDeg+90)%360; rotRange.value=rotationDeg; rotLabel.textContent=`${Number(rotRange.value).toFixed(1)}Â°`; draw(); scheduleValidate(); });
    btnReset.addEventListener('click', ()=>{ reset(false); scheduleValidate(); });
    btnExportSingle.addEventListener('click', exportSingle);
    btnExportA4.addEventListener('click', ()=> makeSheet(2480,3508,'planche_A4_300dpi.png'));
    btnExport10x15.addEventListener('click', export10x15);
    btnExport4x6.addEventListener('click', export4x6);

    // DÃ©tourage
    btnPickBg.addEventListener('click', ()=>{ mode='pickBg'; updateModeUI(); draw(); });
    function pickBgAt(ix,iy){ if(!imgLoaded) return; const x=Math.round(Math.max(0,Math.min(ix,imgCanvas.width-1))); const y=Math.round(Math.max(0,Math.min(iy,imgCanvas.height-1))); bgSamplesXY.push({x,y}); sampleCount.textContent=String(bgSamplesXY.length); btnDetour.disabled = (bgSamplesXY.length===0 || !currentFile); }
    btnResetSamples.addEventListener('click', ()=>{ bgSamplesXY=[]; sampleCount.textContent='0'; btnDetour.disabled=true; });
    btnDetour.addEventListener('click', ()=> generateMaskBackend());
    btnClearMask.addEventListener('click', ()=>{ clearMask(); undoStack.length=0; redoStack.length=0; btnUndo.disabled=true; btnRedo.disabled=true; });
    tolRange.addEventListener('input', ()=>{ if(imgLoaded && bgSamplesXY.length>0 && currentFile) generateMaskBackend(); });
    softRange.addEventListener('input', ()=>{ if(imgLoaded && bgSamplesXY.length>0 && currentFile) generateMaskBackend(); });
    showMask.addEventListener('change', draw);
    btnBrushAdd.addEventListener('click', ()=>{ mode='brushAdd'; showMask.checked=true; updateModeUI(); draw(); });
    btnBrushSub.addEventListener('click', ()=>{ mode='brushSub'; showMask.checked=true; updateModeUI(); draw(); });
    btnUndo.addEventListener('click', ()=>{ if(!undoStack.length) return; const last=undoStack.pop(); redoStack.push(maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height)); maskCtx.putImageData(last,0,0); rebuildSubject(); draw(); btnRedo.disabled=false; if(!undoStack.length) btnUndo.disabled=true; });
    btnRedo.addEventListener('click', ()=>{ if(!redoStack.length) return; const cur=redoStack.pop(); undoStack.push(maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height)); maskCtx.putImageData(cur,0,0); rebuildSubject(); draw(); btnUndo.disabled=false; if(!redoStack.length) btnRedo.disabled=true; });

    if(bgChips){
      bgChips.addEventListener('click', (e)=>{ const b=e.target.closest('.chipBtn'); if(!b) return; [...bgChips.children].forEach(x=>x.classList.remove('active')); b.classList.add('active'); bgColor=b.dataset.bg; draw(); });
      if(bgChips.children.length>0){ bgChips.children[0].classList.add('active'); }
    }

    // Canvas interactions
    can.addEventListener('mousedown', (e)=>{
      const rect=can.getBoundingClientRect(); const x=e.clientX-rect.left; const y=e.clientY-rect.top; const p=canvasToImage(x,y);
      if(mode==='pickBg'){ pickBgAt(p.x,p.y); draw(); return; }
      if(mode==='brushAdd'){ isPainting=true; paintAt(p.x,p.y,true); return; }
      if(mode==='brushSub'){ isPainting=true; paintAt(p.x,p.y,false); return; }
      if(mode && (mode==='chin'||mode==='crown'||mode==='eyeL'||mode==='eyeR')){ setLandmark(mode,p); isDraggingLM=true; dragType=mode; draw(); scheduleValidate(); return; }
      isPanning=true; panStart={x,y}; startTx=tx; startTy=ty;
    });
    window.addEventListener('mouseup', ()=>{ isPanning=false; isDraggingLM=false; dragType=null; isPainting=false; });
    can.addEventListener('mousemove', (e)=>{
      const rect=can.getBoundingClientRect(); const x=e.clientX-rect.left; const y=e.clientY-rect.top;
      if(isPainting && (mode==='brushAdd'||mode==='brushSub')){ const p=canvasToImage(x,y); paintAt(p.x,p.y, mode==='brushAdd'); return; }
      if(isDraggingLM && dragType){ const p=canvasToImage(x,y); setLandmark(dragType,p); draw(); scheduleValidate(); return; }
      if(!isPanning) return; const dx=x-panStart.x; const dy=y-panStart.y; tx=startTx+dx; ty=startTy+dy; draw();
    });
    can.addEventListener('wheel', (e)=>{ e.preventDefault(); const factor=Math.pow(1.001, -e.deltaY); const rect=can.getBoundingClientRect(); const cx=e.clientX-rect.left; const cy=e.clientY-rect.top; const pre=canvasToImage(cx,cy); scale*=factor; scale=Math.max(0.05, Math.min(20, scale)); const post=imageToCanvas(pre.x,pre.y); tx += (cx - post.x); ty += (cy - post.y); draw(); scheduleValidate(); }, {passive:false});

    window.addEventListener('keydown',(e)=>{
      const k=e.key;
      if(k==='1'){ mode='chin'; updateModeUI(); draw(); }
      else if(k==='2'){ mode='crown'; updateModeUI(); draw(); }
      else if(k==='3'){ mode='eyeL'; updateModeUI(); draw(); }
      else if(k==='4'){ mode='eyeR'; updateModeUI(); draw(); }
      else if(k==='Escape'){ mode=null; isPainting=false; isDraggingLM=false; isPanning=false; updateModeUI(); draw(); }
      else if(k==='+'){ scale*=1.02; draw(); scheduleValidate(); }
      else if(k==='-'){ scale/=1.02; draw(); scheduleValidate(); }
      else if(k==='r'||k==='R'){ reset(false); scheduleValidate(); }
    });

    // Landmarks & helpers
    function setLandmark(name, pImg){ if(name==='chin') chin=pImg; else if(name==='crown') crown=pImg; else if(name==='eyeL') eyeL=pImg; else if(name==='eyeR') eyeR=pImg; }
    function autoAdjust(){ if(!imgLoaded || !chin || !crown) return; const chinC=imageToCanvas(chin.x,chin.y), crownC=imageToCanvas(crown.x,crown.y); const current=Math.hypot(crownC.x-chinC.x, crownC.y-chinC.y); if(current<=0.1) return; const factor=FACE_TARGET/current; scale*=factor; const crownCanvas=imageToCanvas(crown.x,crown.y); const targetTop=4*PX_PER_MM; tx += (OUT_W/2 - crownCanvas.x); ty += (targetTop - crownCanvas.y); draw(); }
    function autoEyes(){ const ang=eyesAngleDeg(); if(ang===null) return; rotationDeg -= ang; rotationDeg=Math.max(-10, Math.min(10, rotationDeg)); rotRange.value=rotationDeg; rotLabel.textContent=`${rotationDeg.toFixed(1)}Â°`; draw(); }
    function center(){ tx=OUT_W/2; ty=OUT_H/2; draw(); }
    function reset(all=true){ scale=Math.min(OUT_W/img.width, OUT_H/img.height) || 1; rotationDeg=0; rotRange.value=0; rotLabel.textContent='0.0Â°'; center(); if(all){ chin=null;crown=null;eyeL=null;eyeR=null; clearMask(); bgSamplesXY=[]; sampleCount.textContent='0'; btnDetour.disabled=true; } draw(); }

    // Initial draw
    draw();
  })();
  </script>
</body>
</html>
